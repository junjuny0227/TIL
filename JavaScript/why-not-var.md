# var의 문제점

ES5까지는 `let`과 `const`가 도입되기 전이라 `var`가 유일한 변수 선언 방식이었다. 하지만 `var`는 몇 가지 문제점을 가지고 있다.

## 함수 스코프

`var`로 선언한 변수는 함수 스코프를 가지므로, 함수 내부 어디에서든 접근할 수 있다. 이로 인해 변수 범위를 예측하기 어렵고, 의도치 않은 변수 덮어쓰기나 값 변경이 발생할 수 있다.

```js
function example() {
  if (true) {
    var message = "Hello, world!";
    console.log("내부: ", message); // "내부: Hello, world!"
  }
  console.log("외부: ", message); // "외부: Hello, world!" (블록 외부에서도 접근 가능)
}
```

위의 예제에서 `if`문 내부에서 `var`로 선언한 변수는 함수 스코프를 가지므로, `if`문 외부에서도 접근할 수 있다. 이는 `var`가 블록 스코프를 지원하지 않기 때문에 발생한다.

## 중복 선언

`var`로 선언한 변수는 같은 스코프 내에서 중복 선언이 가능하다. 이로 인해 의도치 않게 기존 변수가 덮어써지는 문제가 발생할 수 있다.

```js
var name = "Kim";
console.log(name); // "Kim"

var name = "Park";
console.log(name); // "Park"
```

위의 예제에서는 `var`를 사용하여 변수 `name`을 두 번 선언하고 각각 다른 값을 할당했다. 다른 프로그래밍 언어나 `let`, `const`와 같은 변수 선언 방식에서는 오류가 발생했겠지만, `var`는 같은 스코프 내에서 중복 선언이 허용되기 때문에 문제가 발생하지 않는다.

만약 큰 프로젝트에서 `var`로 변수를 선언했다면, 동일한 변수명을 사용해도 오류가 발생하지 않기 때문에, 의도치 않은 덮어쓰기와 같은 문제가 생겼을 때 이를 찾아내기가 어렵다.

## 호이스팅

`var`로 선언한 변수는 호이스팅이 발생하여, 변수 선언이 스코프의 상단으로 끌어올려진다. 이로 인해 변수 선언 전에 해당 변수를 참조할 수 있게 되어 예상치 못한 동작이 발생할 수 있다.

```js
console.log(name); // undefined
var name = "Kim";
```

위의 예제에서는 변수 `name`을 선언하기 전에 출력을 시도했다. 예상대로라면 **참조 오류**(ReferenceError)가 발생해야 하지만, 실제로는 undefined가 출력된다.

이는 `var`로 선언된 변수가 호이스팅되어 변수가 선언되기 전에 참조할 수 있다는 특징 때문이다. 이렇게 `var`로 선언된 변수의 선언 단계와 초기화 단계가 분리되어 선언 단계만 최상위로 끌어올려지는 것을 호이스팅이라고 한다.
